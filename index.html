<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2주소 시각화 및 구역 관리 시스템</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- SheetJS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

    <style>
        body { font-family: 'Noto Sans KR', sans-serif; overflow: hidden; }
        #map { width: 100%; height: 100%; }
        
        /* 리스트 스타일 */
        .list-row:hover { background-color: #f3f4f6; cursor: pointer; }
        .selected-row { background-color: #eff6ff !important; border-left: 4px solid #2563eb; }
        
        /* 구역 아이템 스타일 */
        .zone-item { transition: all 0.2s; border-left-width: 6px; } 
        .zone-item:hover { transform: translateX(2px); background-color: #f8fafc; }
        .zone-selected { background-color: #eff6ff; box-shadow: inset 0 0 0 1px #bfdbfe; }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
    </style>
</head>
<body class="bg-gray-100 h-screen flex flex-col">

    <!-- 1. 상단 헤더 -->
    <header class="bg-white shadow-md px-6 py-3 z-20 flex justify-between items-center h-16 shrink-0 border-b border-gray-200">
        <div class="flex items-center gap-6">
            <h1 class="text-xl font-bold text-gray-800 flex items-center">
                <i class="fa-solid fa-map-location-dot text-blue-600 text-2xl mr-3"></i>
                <span>구역 관리 시스템</span>
            </h1>
            <div class="h-8 w-px bg-gray-300"></div>
            
            <!-- 파일 업로드 -->
            <div class="flex items-center gap-3">
                <div class="relative">
                    <input type="file" id="excelFile" accept=".xlsx, .xls" class="hidden" onchange="handleFileUpload(event)">
                    <label for="excelFile" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg cursor-pointer text-sm font-medium transition flex items-center shadow-sm">
                        <i class="fa-solid fa-file-excel mr-2"></i>엑셀 업로드
                    </label>
                </div>
                <span id="statusMsg" class="text-sm text-gray-500">준비 완료</span>
            </div>
        </div>

        <!-- 도구 모음 -->
        <div class="flex items-center gap-2 bg-gray-100 p-1.5 rounded-lg">
            <button onclick="selectOverlay('POLYGON')" class="flex items-center gap-2 px-3 py-1.5 bg-white hover:bg-blue-50 text-gray-700 rounded shadow-sm text-sm font-medium transition border border-gray-200 group">
                <i class="fa-solid fa-draw-polygon text-blue-500 group-hover:scale-110 transition-transform"></i>
                구역 그리기
            </button>
            <button onclick="resetAll()" class="flex items-center gap-2 px-3 py-1.5 bg-white hover:bg-red-50 text-gray-700 rounded shadow-sm text-sm font-medium transition border border-gray-200 group">
                <i class="fa-solid fa-rotate-right text-red-500 group-hover:rotate-180 transition-transform duration-500"></i>
                전체 초기화
            </button>
        </div>
    </header>

    <!-- 2. 메인 컨텐츠 -->
    <main class="flex flex-1 overflow-hidden">
        <!-- 좌측: 지도 -->
        <div id="map-container" class="w-[70%] h-full relative bg-gray-200">
            <div id="map"></div>
            <div id="drawGuide" class="absolute top-6 left-1/2 transform -translate-x-1/2 bg-gray-800/90 text-white px-5 py-2.5 rounded-full shadow-xl text-sm font-medium z-50 hidden backdrop-blur-sm flex items-center gap-2 animate-bounce">
                <i class="fa-solid fa-pen-nib"></i>
                <span>지도에 점을 찍어 구역을 만드세요 (우클릭: 완료)</span>
            </div>
        </div>

        <!-- 우측: 패널 -->
        <div class="w-[30%] flex flex-col bg-white h-full shadow-xl z-30 border-l border-gray-200">
            <!-- 통계 카드 -->
            <div class="p-5 border-b bg-gray-50/50">
                <div class="flex justify-between items-center mb-3">
                    <h2 class="text-sm font-bold text-gray-600 uppercase tracking-wider">현황판</h2>
                    <span class="text-xs text-gray-400 bg-white border px-2 py-1 rounded">Total: <span id="totalCount" class="text-gray-800 font-bold">0</span>명</span>
                </div>
                
                <div class="mb-2">
                    <div class="text-xs text-gray-500 mb-2 flex justify-between items-center">
                        <span>생성된 구역 목록</span>
                        <button onclick="viewAllData()" class="text-blue-600 hover:underline cursor-pointer text-xs font-medium">전체 보기</button>
                    </div>
                    <!-- 구역 목록 컨테이너 -->
                    <div id="zoneListContainer" class="space-y-2 max-h-[180px] overflow-y-auto pr-1">
                        <div class="text-center py-4 text-gray-400 text-xs bg-gray-50 rounded border border-dashed">
                            생성된 구역이 없습니다.<br>지도의 '구역 그리기'를 이용하세요.
                        </div>
                    </div>
                </div>
            </div>

            <!-- 인원 리스트 -->
            <div class="flex items-center justify-between px-4 py-2 bg-gray-100 border-b border-t border-gray-200 text-xs font-medium text-gray-600 sticky top-0">
                <span>인원 명단 (<span id="currentViewCount">0</span>명)</span>
                <span id="currentFilterName" class="text-blue-600">전체 보기</span>
            </div>

            <div class="flex-1 overflow-y-auto bg-white relative">
                <table class="w-full text-sm text-left">
                    <thead class="text-xs text-gray-500 uppercase bg-gray-50 sticky top-0 z-10 shadow-sm">
                        <tr>
                            <th class="px-2 py-3 font-semibold text-center w-16">교구/구역</th>
                            <th class="px-2 py-3 font-semibold">이름</th>
                            <th class="px-2 py-3 font-semibold">주소</th>
                            <th class="px-2 py-3 text-center font-semibold w-12">출석</th>
                        </tr>
                    </thead>
                    <tbody id="personList" class="divide-y divide-gray-100">
                        <tr>
                            <td colspan="4" class="text-center py-20 text-gray-400 flex flex-col items-center gap-3">
                                <i class="fa-solid fa-users-slash text-3xl text-gray-300"></i>
                                <span>데이터가 없습니다</span>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </main>

    <!-- 카카오 API -->
    <script type="text/javascript" src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=YOUR_KAKAO_API_KEY&libraries=services,drawing"></script>

    <script>
        // --- 전역 변수 ---
        let map, geocoder, drawingManager;
        let allData = [];
        let zones = [];   
        let zoneCounter = 1; 
        let selectedMarker = null;

        // --- [핵심] 마커 색상 생성 함수 ---
        // 교구별 기본 색상 (HSL format)
        const PARISH_COLORS = {
            '1교구': { h: 220, s: 90, baseL: 50 }, // 파랑
            '2교구': { h: 0,   s: 90, baseL: 50 }, // 빨강
            '3교구': { h: 120, s: 90, baseL: 40 }, // 초록
            '4교구': { h: 45,  s: 100, baseL: 50 }, // 노랑
            'default': { h: 0, s: 0, baseL: 50 }   // 회색
        };

        // SVG 마커 이미지를 동적으로 생성하는 함수
        function createSvgMarkerUrl(colorHex) {
            // 핀 모양의 SVG (색상은 colorHex로 채움)
            const svgString = `
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="35" height="45">
                    <path fill="${colorHex}" stroke="white" stroke-width="1" 
                        d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7z"/>
                    <circle cx="12" cy="9" r="3.5" fill="white"/>
                </svg>`;
            return 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(svgString);
        }

        // 교구와 구역 정보를 받아 색상(Hex)을 반환하는 함수
        function getMarkerColor(parish, zone) {
            // 1. 교구 정보 파싱 (예: "1교구" -> "1교구")
            let pInfo = PARISH_COLORS[parish] || PARISH_COLORS['default'];
            
            // 2. 구역 정보에서 숫자 추출 (예: "3구역" -> 3)
            let zNum = 1;
            if (zone) {
                const match = zone.match(/\d+/);
                if (match) zNum = parseInt(match[0]);
            }

            // 3. 농도(Lightness) 조절: 구역 숫자가 클수록 밝게(연하게) 처리
            // 구역 1: Base, 구역 2: +10%, 구역 3: +20% ...
            // 너무 밝아지지 않도록 최대 90% 제한
            let lightness = Math.min(90, pInfo.baseL + (zNum - 1) * 12);
            
            return `hsl(${pInfo.h}, ${pInfo.s}%, ${lightness}%)`;
        }

        // --- 1. 초기화 ---
        window.onload = function() {
            if (!window.kakao || !window.kakao.maps) {
                alert("API 로드 실패: YOUR_KAKAO_API_KEY를 확인하세요.");
                return;
            }

            kakao.maps.load(function() {
                const container = document.getElementById('map');
                const options = { center: new kakao.maps.LatLng(37.566826, 126.9786567), level: 7 };
                map = new kakao.maps.Map(container, options);
                
                geocoder = new kakao.maps.services.Geocoder();

                try {
                    drawingManager = new kakao.maps.drawing.DrawingManager({
                        map: map,
                        drawingMode: [kakao.maps.drawing.OverlayType.POLYGON],
                        guideTooltip: ['draw', 'drag', 'edit'],
                        polygonOptions: {
                            draggable: false, removable: false, strokeWeight: 2, strokeOpacity: 0.8, fillOpacity: 0.3
                        }
                    });
                    drawingManager.addListener('drawend', handleDrawEnd);
                } catch (e) {
                    console.error(e);
                }
            });
        };

        // --- 2. 그리기 완료 핸들러 ---
        function handleDrawEnd(data) {
            try {
                document.getElementById('drawGuide').classList.add('hidden');
                const polygon = data.target;
                
                // 사용자 구역은 랜덤 색상 사용
                const color = `hsl(${Math.floor(Math.random() * 360)}, 70%, 50%)`;
                polygon.setOptions({ fillColor: color, strokeColor: color });

                let insidePeople = [];
                if (allData.length > 0) {
                    const path = polygon.getPath();
                    insidePeople = allData.filter(p => isInsidePolygon({x: p.lng, y: p.lat}, path));
                }

                const zoneId = zoneCounter++;
                const zoneName = `사용자 구역 ${zoneId}`;
                
                const zoneData = { id: zoneId, name: zoneName, polygon: polygon, people: insidePeople, color: color };
                zones.push(zoneData);

                renderZoneList();
                setTimeout(() => filterByZone(zoneId), 100);
            } catch (err) {
                console.error(err);
            }
        }

        // --- 3. 엑셀 파일 처리 ---
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const jsonData = XLSX.utils.sheet_to_json(workbook.Sheets[workbook.SheetNames[0]]);
                    
                    if (jsonData.length > 0) processData(jsonData);
                    else alert("엑셀 파일에 데이터가 없습니다.");
                } catch (err) {
                    alert("오류 발생: " + err.message);
                }
            };
            reader.readAsArrayBuffer(file);
            event.target.value = '';
        }

        async function processData(data) {
            if (!geocoder || !map) { alert("지도가 로드되지 않았습니다."); return; }

            document.getElementById('statusMsg').innerText = `데이터 처리 중...`;
            if(allData.length > 0) allData.forEach(d => d.marker.setMap(null));
            allData = [];
            
            let processed = 0;

            for (const [idx, row] of data.entries()) {
                const address = row['주소'] || row['Address'] || '';
                if (!address) continue;

                const name = row['이름'] || row['Name'] || '미상';
                const parish = row['교구'] || '';
                const zone = row['구역'] || '';
                
                // 색상 계산 (교구/구역 정보 기반)
                const colorHex = getMarkerColor(parish, zone);
                
                // 동적 마커 이미지 생성
                const markerImageSrc = createSvgMarkerUrl(colorHex);
                const markerImage = new kakao.maps.MarkerImage(markerImageSrc, new kakao.maps.Size(35, 45), { offset: new kakao.maps.Point(17, 45) });

                await new Promise(resolve => {
                    geocoder.addressSearch(address, (result, status) => {
                        if (status === kakao.maps.services.Status.OK) {
                            const lat = parseFloat(result[0].y);
                            const lng = parseFloat(result[0].x);
                            
                            const marker = new kakao.maps.Marker({
                                map: map,
                                position: new kakao.maps.LatLng(lat, lng),
                                title: name,
                                image: markerImage // SVG 마커 적용
                            });

                            const personData = { 
                                id: idx, name, address, parish, zone,
                                role: row['직분'] || '-', 
                                attendance: row['출석여부'] || 'X',
                                lat, lng, marker,
                                originalImage: markerImage // 원래 색상 저장 (강조 해제 시 복구용)
                            };

                            kakao.maps.event.addListener(marker, 'click', () => highlightPerson(personData));
                            allData.push(personData);
                            processed++;
                        }
                        resolve();
                    });
                });
                
                if (idx % 10 === 0) document.getElementById('statusMsg').innerText = `${idx}/${data.length} 처리 중...`;
            }

            document.getElementById('statusMsg').innerText = `완료 (${processed}건)`;
            document.getElementById('totalCount').innerText = processed;
            
            renderTable(allData);
            
            if(allData.length > 0) {
                const bounds = new kakao.maps.LatLngBounds();
                allData.forEach(d => bounds.extend(d.marker.getPosition()));
                map.setBounds(bounds);
            }
        }

        // --- 4. UI 및 유틸리티 ---
        function selectOverlay(type) {
            if(!drawingManager) return;
            drawingManager.cancel();
            drawingManager.select(kakao.maps.drawing.OverlayType[type]);
            document.getElementById('drawGuide').classList.remove('hidden');
        }

        function renderZoneList() {
            const container = document.getElementById('zoneListContainer');
            container.innerHTML = zones.length === 0 ? `<div class="text-center py-4 text-gray-400 text-xs bg-gray-50 border border-dashed">구역 없음</div>` : '';

            zones.forEach(zone => {
                const div = document.createElement('div');
                div.className = `zone-item flex justify-between items-center p-2 bg-white border rounded shadow-sm cursor-pointer mb-2`;
                div.style.borderLeftColor = zone.color;
                div.setAttribute('data-id', zone.id);
                div.onclick = () => filterByZone(zone.id);
                div.innerHTML = `
                    <div class="flex items-center gap-2">
                        <span class="font-bold text-gray-700 text-sm">${zone.name}</span>
                        <span class="bg-gray-100 text-gray-600 text-xs px-1.5 py-0.5 rounded border">${zone.people.length}</span>
                    </div>
                    <button onclick="deleteZone(event, ${zone.id})" class="text-gray-400 hover:text-red-500"><i class="fa-solid fa-trash-can"></i></button>
                `;
                container.appendChild(div);
            });
        }

        function filterByZone(zoneId) {
            const zone = zones.find(z => z.id === zoneId);
            if (!zone) return;
            document.querySelectorAll('.zone-item').forEach(el => el.classList.remove('zone-selected'));
            const item = document.querySelector(`.zone-item[data-id='${zoneId}']`);
            if(item) item.classList.add('zone-selected');
            
            const titleEl = document.getElementById('currentFilterName');
            titleEl.innerText = zone.name;
            titleEl.style.color = zone.color;
            renderTable(zone.people);
        }

        function deleteZone(e, zoneId) {
            e.stopPropagation();
            if(!confirm("삭제하시겠습니까?")) return;
            const idx = zones.findIndex(z => z.id === zoneId);
            if(idx > -1) {
                zones[idx].polygon.setMap(null);
                zones.splice(idx, 1);
                renderZoneList();
                viewAllData();
            }
        }

        function viewAllData() {
            document.querySelectorAll('.zone-item').forEach(el => el.classList.remove('zone-selected'));
            const titleEl = document.getElementById('currentFilterName');
            titleEl.innerText = "전체 보기";
            titleEl.style.color = "#2563eb";
            renderTable(allData);
        }

        function resetAll() {
            if(!confirm("초기화 하시겠습니까?")) return;
            zones.forEach(z => z.polygon.setMap(null));
            zones = [];
            allData.forEach(d => d.marker.setMap(null));
            allData = [];
            zoneCounter = 1;
            renderZoneList();
            renderTable([]);
            document.getElementById('totalCount').innerText = "0";
        }

        function highlightPerson(person) {
            if (selectedMarker && selectedMarker !== person.marker) {
                // 이전 마커 복구 (원래 이미지로)
                const prevData = allData.find(p => p.marker === selectedMarker);
                if (prevData) selectedMarker.setImage(prevData.originalImage);
                selectedMarker.setZIndex(0);
            }
            
            // 선택된 마커 강조 (검정 테두리 빨간핀)
            const selectedImgSrc = createSvgMarkerUrl('#FF0000'); // 강조색
            const selectedImg = new kakao.maps.MarkerImage(selectedImgSrc, new kakao.maps.Size(40, 50), { offset: new kakao.maps.Point(20, 50) });
            
            person.marker.setImage(selectedImg);
            person.marker.setZIndex(999);
            selectedMarker = person.marker;
            map.panTo(person.marker.getPosition());

            document.querySelectorAll('.list-row').forEach(r => r.classList.remove('selected-row'));
            const targetRow = document.getElementById(`row-${person.id}`);
            if (targetRow) {
                targetRow.classList.add('selected-row');
                targetRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        function renderTable(data) {
            document.getElementById('currentViewCount').innerText = data.length;
            const tbody = document.getElementById('personList');
            tbody.innerHTML = '';
            if (data.length === 0) {
                tbody.innerHTML = `<tr><td colspan="4" class="text-center py-10 text-gray-400">데이터가 없습니다.</td></tr>`;
                return;
            }
            data.forEach(item => {
                const tr = document.createElement('tr');
                tr.id = `row-${item.id}`;
                tr.className = "border-b list-row transition duration-150";
                
                // 교구/구역에 따른 뱃지 색상 계산 (가독성을 위해 약간 연하게)
                const badgeColor = getMarkerColor(item.parish, item.zone).replace('hsl', 'hsla').replace(')', ', 0.15)');
                const textColor = getMarkerColor(item.parish, item.zone).replace('hsl', 'hsla').replace(')', ', 1.0)'); // 텍스트는 진하게

                tr.innerHTML = `
                    <td class="px-2 py-3 text-center">
                        <div class="text-xs font-bold px-1 py-1 rounded" style="background-color: ${badgeColor}; color: ${textColor}; border: 1px solid ${textColor}">
                            ${item.parish}<br>${item.zone}
                        </div>
                    </td>
                    <td class="px-2 py-3 font-medium text-gray-800 text-sm">${item.name} <span class="text-xs text-gray-500">(${item.role})</span></td>
                    <td class="px-2 py-3 text-xs text-gray-500 truncate max-w-[100px]" title="${item.address}">${item.address}</td>
                    <td class="px-2 py-3 text-center">
                        <span class="px-2 py-0.5 rounded-full text-xs font-bold text-white ${item.attendance === 'O' ? 'bg-green-500' : 'bg-gray-400'}">
                            ${item.attendance}
                        </span>
                    </td>
                `;
                tr.onclick = () => highlightPerson(item);
                tbody.appendChild(tr);
            });
        }

        function isInsidePolygon(point, path) {
            let inside = false;
            const x = point.x, y = point.y;
            for (let i = 0, j = path.length - 1; i < path.length; j = i++) {
                const xi = path[i].getLng(), yi = path[i].getLat();
                const xj = path[j].getLng(), yj = path[j].getLat();
                const intersect = ((yi > y) != (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>주소 시각화 및 구역 관리 시스템</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- SheetJS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

    <style>
        body { font-family: 'Noto Sans KR', sans-serif; overflow: hidden; }
        #map { width: 100%; height: 100%; }
        
        /* 리스트 스타일 */
        .list-row:hover { background-color: #f3f4f6; cursor: pointer; }
        .selected-row { background-color: #eff6ff !important; border-left: 4px solid #2563eb; }
        
        /* 구역 아이템 스타일 */
        .zone-item { transition: all 0.2s; }
        .zone-item:hover { transform: translateX(2px); }
        .zone-selected { border: 2px solid #2563eb; background-color: #eff6ff; }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
    </style>
</head>
<body class="bg-gray-100 h-screen flex flex-col">

    <!-- 1. 상단 헤더 -->
    <header class="bg-white shadow-md px-6 py-3 z-20 flex justify-between items-center h-16 shrink-0 border-b border-gray-200">
        <div class="flex items-center gap-6">
            <h1 class="text-xl font-bold text-gray-800 flex items-center">
                <i class="fa-solid fa-map-location-dot text-blue-600 text-2xl mr-3"></i>
                <span>구역 관리 시스템</span>
            </h1>
            
            <div class="h-8 w-px bg-gray-300"></div>

            <!-- 파일 업로드 -->
            <div class="flex items-center gap-3">
                <div class="relative">
                    <input type="file" id="excelFile" accept=".xlsx, .xls" class="hidden" onchange="handleFileUpload(event)">
                    <label for="excelFile" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg cursor-pointer text-sm font-medium transition flex items-center shadow-sm">
                        <i class="fa-solid fa-file-excel mr-2"></i>엑셀 업로드
                    </label>
                </div>
                <span id="statusMsg" class="text-sm text-gray-500">데이터를 업로드해주세요</span>
            </div>
        </div>

        <!-- 도구 모음 -->
        <div class="flex items-center gap-2 bg-gray-100 p-1.5 rounded-lg">
            <button onclick="selectOverlay('POLYGON')" class="flex items-center gap-2 px-3 py-1.5 bg-white hover:bg-blue-50 text-gray-700 rounded shadow-sm text-sm font-medium transition border border-gray-200 group">
                <i class="fa-solid fa-draw-polygon text-blue-500 group-hover:scale-110 transition-transform"></i>
                구역 그리기
            </button>
            <button onclick="resetAll()" class="flex items-center gap-2 px-3 py-1.5 bg-white hover:bg-red-50 text-gray-700 rounded shadow-sm text-sm font-medium transition border border-gray-200 group">
                <i class="fa-solid fa-rotate-right text-red-500 group-hover:rotate-180 transition-transform duration-500"></i>
                전체 초기화
            </button>
        </div>
    </header>

    <!-- 2. 메인 컨텐츠 -->
    <main class="flex flex-1 overflow-hidden">
        
        <!-- 좌측: 지도 (70%) -->
        <div id="map-container" class="w-[70%] h-full relative bg-gray-200">
            <div id="map"></div>
            
            <!-- 안내 메시지 -->
            <div id="drawGuide" class="absolute top-6 left-1/2 transform -translate-x-1/2 bg-gray-800/90 text-white px-5 py-2.5 rounded-full shadow-xl text-sm font-medium z-50 hidden backdrop-blur-sm flex items-center gap-2 animate-bounce">
                <i class="fa-solid fa-pen-nib"></i>
                <span>지도에 점을 찍어 구역을 만드세요 (우클릭: 완료)</span>
            </div>
        </div>

        <!-- 우측: 패널 (30%) -->
        <div class="w-[30%] flex flex-col bg-white h-full shadow-xl z-30 border-l border-gray-200">
            
            <!-- A. 통계 카드 -->
            <div class="p-5 border-b bg-gray-50/50">
                <div class="flex justify-between items-center mb-3">
                    <h2 class="text-sm font-bold text-gray-600 uppercase tracking-wider">현황판</h2>
                    <span class="text-xs text-gray-400 bg-white border px-2 py-1 rounded">Total: <span id="totalCount" class="text-gray-800 font-bold">0</span>명</span>
                </div>
                
                <!-- 구역 목록 (스크롤) -->
                <div class="mb-2">
                    <div class="text-xs text-gray-500 mb-2 flex justify-between items-center">
                        <span>생성된 구역 목록</span>
                        <button onclick="viewAllData()" class="text-blue-600 hover:underline cursor-pointer text-xs font-medium">전체 보기</button>
                    </div>
                    <div id="zoneListContainer" class="space-y-2 max-h-[150px] overflow-y-auto pr-1">
                        <div class="text-center py-4 text-gray-400 text-xs bg-gray-50 rounded border border-dashed">
                            생성된 구역이 없습니다.<br>지도의 '구역 그리기'를 이용하세요.
                        </div>
                    </div>
                </div>
            </div>

            <!-- B. 인원 리스트 -->
            <div class="flex items-center justify-between px-4 py-2 bg-gray-100 border-b border-t border-gray-200 text-xs font-medium text-gray-600 sticky top-0">
                <span>인원 명단 (<span id="currentViewCount">0</span>명)</span>
                <span id="currentFilterName" class="text-blue-600">전체 보기</span>
            </div>

            <div class="flex-1 overflow-y-auto bg-white relative">
                <table class="w-full text-sm text-left">
                    <thead class="text-xs text-gray-500 uppercase bg-gray-50 sticky top-0 z-10 shadow-sm">
                        <tr>
                            <th class="px-4 py-3 font-semibold">이름</th>
                            <th class="px-4 py-3 font-semibold">주소</th>
                            <th class="px-4 py-3 text-center font-semibold">직분</th>
                            <th class="px-4 py-3 text-center font-semibold">출석</th>
                        </tr>
                    </thead>
                    <tbody id="personList" class="divide-y divide-gray-100">
                        <tr>
                            <td colspan="4" class="text-center py-20 text-gray-400 flex flex-col items-center gap-3">
                                <i class="fa-solid fa-users-slash text-3xl text-gray-300"></i>
                                <span>데이터가 없습니다</span>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </main>

    <script type="text/javascript" src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=1d9268593ca620c81ee6929f1f2de6a3&libraries=services,drawing"></script>

    <script>
        // --- 설정 및 전역 변수 ---
        const COLORS = ['#EF4444', '#F59E0B', '#10B981', '#3B82F6', '#8B5CF6', '#EC4899', '#6366F1']; // 구역 색상 팔레트
        
        // 마커 이미지 설정
        const MARKER_NORMAL = "https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/markerStar.png"; // 파란색(기본)
        const MARKER_SELECTED = "https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/marker_red.png"; // 빨간색(선택됨)

        let map, geocoder, drawingManager;
        let allData = []; // 전체 데이터 저장
        let zones = [];   // 생성된 구역(Polygon) 정보 저장 [{id, polygon, color, count, name}]
        let zoneCounter = 1; // 구역 번호 부여용
        let selectedMarker = null; // 현재 선택된 마커 객체 (색상 변경용)

        // --- 1. 초기화 ---
        window.onload = function() {
            if (!window.kakao || !window.kakao.maps) {
                alert("API 키 오류: 코드를 열어 YOUR_KAKAO_API_KEY를 실제 키로 변경해주세요.\n(또는 로컬 서버가 아닌 file:// 실행 시 보안 문제일 수 있습니다)");
                return;
            }

            kakao.maps.load(function() {
                const container = document.getElementById('map');
                const options = { center: new kakao.maps.LatLng(37.566826, 126.9786567), level: 7 };
                map = new kakao.maps.Map(container, options);
                
                // Geocoder 객체 생성 (이 시점에 반드시 생성되어야 함)
                geocoder = new kakao.maps.services.Geocoder();

                // 그리기 관리자 설정
                drawingManager = new kakao.maps.drawing.DrawingManager({
                    map: map,
                    drawingMode: [kakao.maps.drawing.OverlayType.POLYGON],
                    guideTooltip: ['draw', 'drag', 'edit'],
                    polygonOptions: {
                        draggable: false,
                        removable: false,
                        strokeWeight: 2,
                        strokeOpacity: 0.8,
                        fillOpacity: 0.3
                    }
                });

                // 구역 그리기 완료 이벤트
                drawingManager.addListener('drawend', onDrawEnd);
            });
        };

        // --- 2. 엑셀 데이터 처리 ---
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const jsonData = XLSX.utils.sheet_to_json(workbook.Sheets[workbook.SheetNames[0]]);
                    
                    if (jsonData.length > 0) {
                        processData(jsonData);
                    } else {
                        alert("엑셀 파일에 데이터가 비어있습니다.");
                    }
                } catch (err) {
                    console.error(err);
                    alert("엑셀 파일을 읽는 중 오류가 발생했습니다.");
                }
            };
            reader.readAsArrayBuffer(file);
            
            // [중요] 같은 파일을 다시 선택해도 이벤트가 발생하도록 값 초기화
            event.target.value = '';
        }

        async function processData(data) {
            // 지도나 Geocoder가 준비되지 않았을 경우 방어
            if (!geocoder || !map) {
                alert("지도가 아직 완전히 로드되지 않았습니다. 잠시 후 다시 시도해주세요.");
                return;
            }

            document.getElementById('statusMsg').innerText = `데이터 ${data.length}건 처리 시작...`;
            
            // 초기화: 기존 마커 삭제
            if(allData.length > 0) allData.forEach(d => d.marker.setMap(null));
            allData = [];
            
            let processed = 0;
            
            // 마커 이미지 객체 생성
            const normalImageSize = new kakao.maps.Size(24, 35);
            const normalMarkerImage = new kakao.maps.MarkerImage(MARKER_NORMAL, normalImageSize);

            for (const [idx, row] of data.entries()) {
                const name = row['이름'] || row['Name'] || '미상';
                const address = row['주소'] || row['Address'] || '';
                
                // 주소가 없으면 건너뜀
                if (!address) {
                    console.log(`Row ${idx}: 주소 없음`);
                    continue;
                }

                await new Promise(resolve => {
                    geocoder.addressSearch(address, (result, status) => {
                        if (status === kakao.maps.services.Status.OK) {
                            const lat = parseFloat(result[0].y);
                            const lng = parseFloat(result[0].x);
                            const latLng = new kakao.maps.LatLng(lat, lng);

                            const marker = new kakao.maps.Marker({
                                map: map,
                                position: latLng,
                                title: name,
                                image: normalMarkerImage // 기본 이미지 적용
                            });

                            // 데이터 객체 생성
                            const personData = { 
                                id: idx, name, address, 
                                role: row['직분'] || '-', 
                                attendance: row['출석여부'] || 'X',
                                lat, lng, marker 
                            };

                            // 마커 클릭 이벤트 연결
                            kakao.maps.event.addListener(marker, 'click', () => highlightPerson(personData));

                            allData.push(personData);
                            processed++;
                        } else {
                            console.warn(`주소 변환 실패: ${address} (Status: ${status})`);
                        }
                        resolve(); // 성공이든 실패든 루프 진행을 위해 resolve
                    });
                });
                
                // 진행률 표시 (너무 자주 업데이트하면 느려지므로 5건 단위)
                if (idx % 5 === 0) {
                    document.getElementById('statusMsg').innerText = `${idx + 1}/${data.length}건 분석 중...`;
                }
            }

            if (processed === 0) {
                document.getElementById('statusMsg').innerText = "변환 실패 (API 키 확인 필요)";
                alert("주소를 좌표로 변환하지 못했습니다.\n1. 엑셀의 '주소' 컬럼이 정확한지 확인하세요.\n2. API 키에 '로컬(주소검색)' 권한이 켜져있는지 확인하세요.");
            } else {
                document.getElementById('statusMsg').innerText = `완료 (${processed}건 성공)`;
            }
            
            document.getElementById('totalCount').innerText = processed;
            
            // 전체 보기 렌더링
            renderTable(allData);
            
            // 지도 범위 재설정
            if(allData.length > 0) {
                const bounds = new kakao.maps.LatLngBounds();
                allData.forEach(d => bounds.extend(d.marker.getPosition()));
                map.setBounds(bounds);
            }
        }

        // --- 3. 마커 강조 (Highlight) 로직 ---
        function highlightPerson(person) {
            // 1. 이전에 선택된 마커가 있다면 원래대로 복구
            if (selectedMarker) {
                const normalImg = new kakao.maps.MarkerImage(MARKER_NORMAL, new kakao.maps.Size(24, 35));
                selectedMarker.setImage(normalImg);
                selectedMarker.setZIndex(0); // 우선순위 낮춤
            }

            // 2. 새로 선택된 마커 강조 (빨간색)
            const selectedImg = new kakao.maps.MarkerImage(MARKER_SELECTED, new kakao.maps.Size(29, 42)); // 조금 더 크게
            person.marker.setImage(selectedImg);
            person.marker.setZIndex(999); // 지도 맨 위로 올림
            
            selectedMarker = person.marker; // 현재 선택된 마커 갱신
            map.panTo(person.marker.getPosition()); // 지도 중심 이동

            // 3. 리스트에서도 강조 표시
            document.querySelectorAll('.list-row').forEach(r => r.classList.remove('selected-row'));
            const targetRow = document.getElementById(`row-${person.id}`);
            if (targetRow) {
                targetRow.classList.add('selected-row');
                targetRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        // --- 4. 구역(Polygon) 관리 및 색상 지정 ---
        function selectOverlay(type) {
            if(!drawingManager) return;
            drawingManager.cancel();
            drawingManager.select(kakao.maps.drawing.OverlayType[type]);
            document.getElementById('drawGuide').classList.remove('hidden');
        }

        function onDrawEnd(data) {
            document.getElementById('drawGuide').classList.add('hidden');
            
            const polygon = data.target; // 그려진 폴리곤 객체
            
            // 색상 자동 할당 (순환)
            const color = COLORS[(zoneCounter - 1) % COLORS.length];
            
            // 폴리곤 스타일 변경 (색상 입히기)
            polygon.setOptions({
                fillColor: color,
                strokeColor: color
            });

            // 구역 내 인원 계산
            const path = polygon.getPath();
            const insidePeople = allData.filter(p => isInsidePolygon({x: p.lng, y: p.lat}, path));

            // 구역 정보 저장
            const zoneId = zoneCounter++;
            const zoneName = `구역 ${zoneId}`;
            
            const zoneData = {
                id: zoneId,
                name: zoneName,
                polygon: polygon,
                people: insidePeople,
                color: color
            };
            zones.push(zoneData);

            // UI 업데이트
            renderZoneList();
            
            // 자동으로 해당 구역 필터링해서 보여주기
            filterByZone(zoneId);
        }

        // --- 5. 구역 목록 UI 및 필터링 ---
        function renderZoneList() {
            const container = document.getElementById('zoneListContainer');
            if (zones.length === 0) {
                container.innerHTML = `<div class="text-center py-4 text-gray-400 text-xs bg-gray-50 rounded border border-dashed">생성된 구역이 없습니다.</div>`;
                return;
            }

            container.innerHTML = '';
            zones.forEach(zone => {
                const div = document.createElement('div');
                div.className = `zone-item flex justify-between items-center p-2 bg-white border rounded shadow-sm cursor-pointer mb-2 border-l-4`;
                div.style.borderLeftColor = zone.color; // 구역 색상 표시
                div.onclick = () => filterByZone(zone.id);
                
                div.innerHTML = `
                    <div class="flex items-center gap-2">
                        <span class="font-bold text-gray-700 text-sm">${zone.name}</span>
                        <span class="bg-gray-100 text-gray-600 text-xs px-1.5 py-0.5 rounded">${zone.people.length}명</span>
                    </div>
                    <button onclick="deleteZone(event, ${zone.id})" class="text-gray-400 hover:text-red-500 p-1 rounded hover:bg-red-50 transition">
                        <i class="fa-solid fa-xmark"></i>
                    </button>
                `;
                container.appendChild(div);
            });
        }

        function filterByZone(zoneId) {
            const zone = zones.find(z => z.id === zoneId);
            if (!zone) return;

            // 리스트 하이라이트 효과
            document.querySelectorAll('.zone-item').forEach(el => el.classList.remove('zone-selected'));
            const clickedItem = Array.from(document.querySelectorAll('.zone-item')).find(el => el.innerHTML.includes(zone.name));
            if(clickedItem) clickedItem.classList.add('zone-selected');

            document.getElementById('currentFilterName').innerText = `${zone.name} (색상구분)`;
            document.getElementById('currentFilterName').style.color = zone.color;
            
            renderTable(zone.people); // 필터링된 데이터만 렌더링
        }

        function viewAllData() {
            document.querySelectorAll('.zone-item').forEach(el => el.classList.remove('zone-selected'));
            document.getElementById('currentFilterName').innerText = "전체 보기";
            document.getElementById('currentFilterName').style.color = "#2563eb";
            renderTable(allData);
        }

        function deleteZone(e, zoneId) {
            e.stopPropagation(); // 부모 클릭 방지
            if(!confirm("이 구역을 삭제하시겠습니까?")) return;

            const idx = zones.findIndex(z => z.id === zoneId);
            if(idx > -1) {
                zones[idx].polygon.setMap(null); // 지도에서 제거
                zones.splice(idx, 1); // 배열에서 제거
                renderZoneList();
                viewAllData(); // 전체 보기로 복귀
            }
        }

        function resetAll() {
            if(!confirm("모든 데이터를 초기화하시겠습니까?")) return;
            zones.forEach(z => z.polygon.setMap(null));
            zones = [];
            allData.forEach(d => d.marker.setMap(null));
            allData = [];
            zoneCounter = 1;
            renderZoneList();
            renderTable([]);
            document.getElementById('statusMsg').innerText = "초기화됨";
            document.getElementById('totalCount').innerText = "0";
        }

        // --- 6. 공통 함수 (알고리즘 & 테이블) ---
        function renderTable(data) {
            document.getElementById('currentViewCount').innerText = data.length;
            const tbody = document.getElementById('personList');
            tbody.innerHTML = '';

            if (data.length === 0) {
                tbody.innerHTML = `<tr><td colspan="4" class="text-center py-10 text-gray-400">표시할 데이터가 없습니다.</td></tr>`;
                return;
            }

            data.forEach(item => {
                const tr = document.createElement('tr');
                tr.id = `row-${item.id}`;
                tr.className = "border-b list-row transition duration-150";
                tr.innerHTML = `
                    <td class="px-4 py-3 font-medium text-gray-800">${item.name}</td>
                    <td class="px-4 py-3 text-xs text-gray-500 truncate max-w-[120px]" title="${item.address}">${item.address}</td>
                    <td class="px-4 py-3 text-center text-xs text-gray-600">${item.role}</td>
                    <td class="px-4 py-3 text-center">
                        <span class="px-2 py-0.5 rounded-full text-xs font-bold text-white ${item.attendance === 'O' ? 'bg-green-500' : 'bg-gray-400'}">
                            ${item.attendance}
                        </span>
                    </td>
                `;
                tr.onclick = () => highlightPerson(item); // 클릭 시 마커 강조
                tbody.appendChild(tr);
            });
        }

        function isInsidePolygon(point, path) {
            let inside = false;
            const x = point.x, y = point.y;
            for (let i = 0, j = path.length - 1; i < path.length; j = i++) {
                const xi = path[i].getLng(), yi = path[i].getLat();
                const xj = path[j].getLng(), yj = path[j].getLat();
                const intersect = ((yi > y) != (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }
    </script>
</body>
</html>
